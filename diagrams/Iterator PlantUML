@startuml
interface Team <<Interface>> {
  + getName(): String
  + getOrderedTeam(): TeamOrdering
  + getReversedTeam(): TeamOrdering
}
note right: Aggregate


class TeamList implements Team {
  - name: String
  + TeamList(name: String, pets: List<GamePet>)
  + TeamList(other: Team)
  + getName(): String
  + getOrderedTeam(): TeamOrdering
  + getReversedTeam(): TeamOrdering
}
note right: ConcreteAggregate


interface TeamOrdering <<Interface>> {
  + getNextPet(): GamePet throws NoRemainingPetsException
  + hasRemainingPets(): boolean
}
note left: Iterator


class OrderedTeam implements TeamOrdering {
  - currentIndex: int
  - pets: Team
  + OrderedTeam(pets: Team)
  + getNextPet(): GamePet throws NoRemainingPetsException
  + hasRemainingPets(): boolean
}
note left: ConcreteIteratorA

class ReversedTeam implements TeamOrdering {
  - currentIndex: int
  - pets: Team
  + ReversedTeam(pets: Team)
  + getNextPet(): GamePet throws NoRemainingPetsException
  + hasRemainingPets(): boolean
}
note right: ConcreteIteratorB


class BattleRunner {
  - cli: CommandLineInterface
  - battlePrinter: BattlePrinter
  - leftTeam: Team
  - rightTeam: Team
  + BattleRunner(cli: CommandLineInterface, leftTeam: Team, rightTeam: Team)
  + startBattle(): void
  + roundBattle(leftTeam: Team, rightTeam: Team): boolean
}
note right: Client

Team -.-> TeamOrdering
BattleRunner --> Team
BattleRunner --> TeamOrdering
TeamList <--> ReversedTeam
TeamList <--> OrderedTeam
@enduml
