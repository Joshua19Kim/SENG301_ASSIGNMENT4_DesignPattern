@startuml
top to bottom direction

package abilities {
    class AbilityCreator {
      - random: Random
      + <<static>> getRandomAbility(): SpecialAbility
    }

    interface SpecialAbility <<Strategy>> {
        + useSpecialAbility(self: GamePet, other: GamePet, cli: CommandLineInterface) : void
    }

    class BuffSelf <<ConcreteStrategyA>> {
        + useSpecialAbility(self: GamePet, other: GamePet, cli: CommandLineInterface) : void
    }

    class HealSelf <<ConcreteStrategyB>> {
        + useSpecialAbility(self: GamePet, other: GamePet, cli: CommandLineInterface) : void
    }

    class HealBoth <<ConcreteStrategyC>> {
        + useSpecialAbility(self: GamePet, other: GamePet, cli: CommandLineInterface) : void
    }

    class DebuffEnemy <<ConcreteStrategyD>> {
        + useSpecialAbility(self: GamePet, other: GamePet, cli: CommandLineInterface) : void
    }
}

package accessor {
    class PackAccessor {
      + createPack(name: String, player: Player, pets: List<Pet>): Pack
    }

    class PetAccessor {
      + createPet(name: String, attack: int, health: int, tier: int): Pet
    }

    class PlayerAccessor {
      + createPlayer(name: String): Player
    }
}

package battle {
    class BattlePrinter {
      - cli: CommandLineInterface
      + BattlePrinter(cli: CommandLineInterface)
      + printBattleSnapshot(leftTeam: Team, rightTeam: Team): void
      + teamPrinter(): void
    }

    class BattleRunner {
      - cli: CommandLineInterface
      - battlePrinter: BattlePrinter
      - leftTeam: Team
      - rightTeam: Team
      + BattleRunner(cli: CommandLineInterface, leftTeam: Team, rightTeam: Team)
      + startBattle(): void
      + roundBattle(leftTeam: Team, rightTeam: Team): boolean
    }

    class NoRemainingPetsException extends RuntimeException {
        + NoRemainingPetsException()
    }

    interface Team <<Aggregate>> {
      + getName(): String
      + getOrderedTeam(): TeamOrdering
      + getReversedTeam(): TeamOrdering
    }

    class TeamList <<ConcreteAggregate>> implements Team {
      - NAME: String
      + TeamList(name: String, pets: List<GamePet>)
      + TeamList(other: Team)
      + getName(): String
      + getOrderedTeam(): TeamOrdering
      + getReversedTeam(): TeamOrdering
    }

    interface TeamOrdering <<Iterator>> {
      + getNextPet(): GamePet
      + hasRemainingPets(): boolean
    }

    class OrderedTeam <<ConcreteIteratorA>> implements TeamOrdering {
      - PETS: Team
      + OrderedTeam(pets: Team)
      + getNextPet(): GamePet
      + hasRemainingPets(): boolean
    }

    class ReversedTeam <<ConcreteIteratorB>> implements TeamOrdering {
      - PETS: Team
      + ReversedTeam(pets: Team)
      + getNextPet(): GamePet
      + hasRemainingPets(): boolean
    }
}

package cli {
    class CommandLineInterface {
      - cli: Scanner
      - printer: PrintStream
      + CommandLineInterface(inputStream: InputStream, printStream: PrintStream)
      + setInputStream(inputStream): void
      + getNextLine(): String
    }
}

package model {
    interface CloneablePet <<Prototype>> {
        + getGamePet() : GamePet
    }
    class Pet <<ConcretePrototype>> {
        + Pet()
        + getGamePet() : GamePet
}

    class GamePet <<SubclassPrototype, Context>> extends Pet {
        - SPECIALABILITY : SpecialAbility
        + GamePet(String, int, int, String)
        + GamePet(String, int, int, String, SpecialAbility)
        + getGamePet() : GamePet
        + getSpecialAbility() : SpecialAbility
    }

    class Player {
      - List<Pack> packs
      + getPacks(): List<Pack>
      + setPacks(List<Pack>): void
    }

    class Pack {
      - player: Player
      - pets: List<Pet>
      + setPlayer(): void
      + getPlayer(): Player
      + getPets(): List<Pet>
      + setPets(List<pet>): List<pet>
      + addPets(Pet... pets): void

    }
}

package pets {
    interface PetGenerator <<Subject>> {
        + getRandomPet(): Pet
    }

    class PetService <<RealSubject>> {
        + getRandomPet(): Pet
        + getResponseFromAPI(): String
    }

    class PetProxy <<Proxy>> {
        - petService: PetService
        + getRandomPet(): Pet
    }

    class PetResponse {
        - String name
        - int attack
        - int health
        - int tier
        - String emoji
        + PetResponse()
        + toPet(): Pet
    }
}

class App {
    + main(String[]): void
}

class Game {
    - static Logger LOGGER
    - CommandLineInterface cli
    - PlayerAccessor playerAccessor
    - PackAccessor packAccessor
    - PetAccessor petAccessor
    - PetGenerator petGenerator
    - HashMap<String, Team> teams
    - Random random
    + <<Constructor>> Game()

    + createPlayer(input: String): void
    + createPack(input: String): void
    + addToPack(input: String): void
    + buildTeam(input: String): void
    + battle(input: String): void
}

PetGenerator <|- PetProxy
PetGenerator <|- PetService
PetProxy "1" *--- "1" PetService
Game --> PetGenerator: > uses

Team -.-> TeamOrdering
BattleRunner --> Team : > gets
BattleRunner --> TeamOrdering : > uses
TeamList <--> ReversedTeam
TeamList <--> OrderedTeam

Game --> CloneablePet : > clones
CloneablePet <|.. Pet

PackAccessor --> Pack
PackAccessor --> Player
PackAccessor --> Pet
PetAccessor --> Pet
PetAccessor --> Pack
PlayerAccessor --> Player
Player --> Pack
Pack --> Pet

BattleRunner --> GamePet : > uses
GamePet *--> "1" SpecialAbility
SpecialAbility <|.. BuffSelf
SpecialAbility <|.. HealSelf
SpecialAbility <|.. HealBoth
SpecialAbility <|.. DebuffEnemy
BattleRunner -.-> BuffSelf
BattleRunner -.-> HealSelf
BattleRunner -.-> HealBoth
BattleRunner -.-> DebuffEnemy

AbilityCreator --> SpecialAbility
AbilityCreator --> BuffSelf
AbilityCreator --> HealSelf
AbilityCreator --> HealBoth
AbilityCreator --> DebuffEnemy

PetService --> PetResponse
App --> Game

Game --> PlayerAccessor
Game --> PackAccessor
Game --> PetAccessor
Game --> CommandLineInterface
Game --> Team
Game --> BattleRunner
Game --> Player
Game --> Pack
@enduml